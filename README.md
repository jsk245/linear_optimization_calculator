# Linear Optimization Calculator
## Description
This is a command-line tool that allows the user to solve a couple different problems related to linear optimization. It can:
1. Solve linear programming (lp) problems
2. Solve pure integer programming problems (see potential sources of error below)
3. Solve mixed integer programming problems (see potential sources of error below)
4. Setup a table for transportation problems
## Commands
### solve-mip
The solve-mip command is used to solve the first 3 types of problems listed above. It is immediately followed by a file name containing the information for the problem (formatting described below), and the solve-mip command has 3 options assocated with it:
1. --num-cutting-planes (used to change the number of cutting planes used in problems involving integers; default=3)
2. --outfile (prints the output to a file if desired)
3. --no-include-brackets (if you want the final tableau to be printed without brackets)

This is an example command using these options:

`python calculator.py mip_example5.txt --num-cutting-planes=1 --outfile=myfile.txt`
### setup-transport-problem
The setup-transport-problem command relates to the fourth type of problem listed above. It is immediately followed by a file name containing the information for the problem (formatting described below), and the setup-transport-problem command has 3 options assocated with it:
1. --method (decides what algorithm to use when setting up the table, where method=0 corresponds to the min-cost rule, method=1 corresponds to Vogel's method, and method=2 corresponds to Larson's method; default=2)
2. --outfile (prints the output to a file if desired)
3. --no-include-brackets (if you want the final tableau to be printed without brackets)

This is an example command using these options:

`python calculator.py setup-transport-problem transportation_example.txt --method=1`
### compare-simplex-speeds
The compare-simplex-speeds command relates to the first type of problem listed above, but it does not solve any specific lp problems. Instead, it is used to compare the speeds of the vectorized and unvectorized versions of the simplex method used to solve lp problems. The command auto generates random lp problems based on 3 args that immediately follow the command: a positive integer describing the minimum number of variables included in the generated lp problems, a positive integer describing the maximum number of variables included in the generated lp problems, and a positive integer describing the number of random lp problems generated. The command also has 2 options assocated with it:
1. --print-reps (prints a message each time 10% of the problems have been completed)
2. --ignore-np-warnings (ignores any warnings generated by numpy)

This is an example command using these options:

`python calculator.py compare-simplex-speeds 500 1000 100 --print_reps`

(Note: this will take probably around 10-15min to complete, but you should find that the vectorized version is almost 2000x faster!)
## Format
### solve-mip 
I include 7 examples of files that solve-mip can read in this repo. Here are some general rules to be followed:
1. Use "obj:" to designate the objective function, "var:" or "intvar:" to introduce variables, and "constraint:" to introduce constraints
2. After writing the objective function, variable information, or constraint information, type a semicolon
3. I assume that all objective functions are given in their maximization form. Just multiply by -1 if you have a minimization problem
4. When introducing a variable using "var:", only write the variable name (like "var: x1;") or the variable name with >= 0 (like "var: x1 >= 0;")
5. When introducing integral variables, use "intvar:". We assume that all integral variables are greater than or equal to 0.
6. All constraints must include ">=", "<=", or "=", where the first two cannot have a space before the "=" sign.
7. Do not use mathematical symbols in variable names other than numbers
8. Always use the multiplication symbol (\*) in constraints if there is a coefficient in front of a variable
9. Declare all variables used in the constraints
10. Don't try to add a negative number, just use subtraction
11. Don't use parentheses
12. If the constraint value is negative, write "-" before the number with no space
13. Make sure all constraints are written so that all variables are on the left and the value is on the right

### setup-transport-problem
I include 1 example of a file that setup-transport-problem can read in this repo. Here are some general rules to be followed:
1. Use "supply:" to introduce the supply, "demand:" to introduce the demand, and "costs:" to introduce the costs
2. Separate all numbers with a comma and include a semicolon at the end of each of these 3 sections
3. If there are n factories, and we view the costs as a matrix as shown in the example file, there should be n columns, each corresponding to one factory

## Descriptions of Examples included
1. mip_example1.txt - a generic lp problem
2. mip_example2.txt - an lp problem with an unbounded solution
3. mip_example3.txt - an lp problem with a negative constraint value 
4. mip_example4.txt - a pure integer problem
5. mip_example5.txt - a mixed integer problem
6. mip_example6.txt - an lp problem using the ">=", "<=", and "=" signs in the constraints
7. mip_example7.txt - an lp problem with an unbounded variable
8. transportation_example.txt - a generic transportation setup problem

## Potential Sources of Error
Linear programming and transportation setup problems should be reliably solved using this calculator (or the calculator will return an error if there are no solutions), but problems involving variables that are restricted to integers may lead to some errors. Since integer programming is NP-hard, lots of computation is needed to solve many of these problems, and in this current implementation, there may be memory issues encountered if the tableaus become too large. Another issue is that floating point arithmetic leads to some integers being reported as numbers with a decimal component, which means that the calculator will likely miss the optimal solution in these cases. Finally, there may be issues with overflow in general if numbers are too small as solving these types of problems involves division.
